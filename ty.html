<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ty 模块：类型的表示 - Guide to Rustc Development</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A guide to developing rustc">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="about-this-guide.html">关于</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="part-1-intro.html"><strong aria-hidden="true">1.</strong> Part 1: 构建，调试和向rustc贡献代码</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="compiler-team.html"><strong aria-hidden="true">1.1.</strong> About the compiler team</a></li><li class="chapter-item "><a href="building/how-to-build-and-run.html"><strong aria-hidden="true">1.2.</strong> 如何构建并运行编译器</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="building/suggested.html"><strong aria-hidden="true">1.2.1.</strong> 推荐的工作流程</a></li><li class="chapter-item "><a href="building/bootstrapping.html"><strong aria-hidden="true">1.2.2.</strong> 编译器自举</a></li><li class="chapter-item "><a href="building/build-install-distribution-artifacts.html"><strong aria-hidden="true">1.2.3.</strong> Distribution artifacts</a></li><li class="chapter-item "><a href="building/compiler-documenting.html"><strong aria-hidden="true">1.2.4.</strong> Documenting Compiler</a></li><li class="chapter-item "><a href="building/ctags.html"><strong aria-hidden="true">1.2.5.</strong> ctags</a></li></ol></li><li class="chapter-item "><a href="tests/intro.html"><strong aria-hidden="true">1.3.</strong> The compiler testing framework</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tests/running.html"><strong aria-hidden="true">1.3.1.</strong> Running tests</a></li><li class="chapter-item "><a href="tests/adding.html"><strong aria-hidden="true">1.3.2.</strong> Adding new tests</a></li><li class="chapter-item "><a href="compiletest.html"><strong aria-hidden="true">1.3.3.</strong> Using compiletest + commands to control test execution</a></li></ol></li><li class="chapter-item "><a href="walkthrough.html"><strong aria-hidden="true">1.4.</strong> Walkthrough: a typical contribution</a></li><li class="chapter-item "><a href="bug-fix-procedure.html"><strong aria-hidden="true">1.5.</strong> Bug Fix Procedure</a></li><li class="chapter-item "><a href="implementing_new_features.html"><strong aria-hidden="true">1.6.</strong> Implementing new features</a></li><li class="chapter-item "><a href="stability.html"><strong aria-hidden="true">1.7.</strong> Stability attributes</a></li><li class="chapter-item "><a href="stabilization_guide.html"><strong aria-hidden="true">1.8.</strong> Stabilizing Features</a></li><li class="chapter-item "><a href="compiler-debugging.html"><strong aria-hidden="true">1.9.</strong> Debugging the Compiler</a></li><li class="chapter-item "><a href="profiling.html"><strong aria-hidden="true">1.10.</strong> Profiling the compiler</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="profiling/with_perf.html"><strong aria-hidden="true">1.10.1.</strong> with the linux perf tool</a></li></ol></li><li class="chapter-item "><a href="conventions.html"><strong aria-hidden="true">1.11.</strong> Coding conventions</a></li><li class="chapter-item "><a href="crates-io.html"><strong aria-hidden="true">1.12.</strong> crates.io Dependencies</a></li><li class="chapter-item "><a href="diagnostics.html"><strong aria-hidden="true">1.13.</strong> Emitting Errors and other Diagnostics</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="diagnostics/lintstore.html"><strong aria-hidden="true">1.13.1.</strong> LintStore</a></li><li class="chapter-item "><a href="diagnostics/diagnostic-codes.html"><strong aria-hidden="true">1.13.2.</strong> Diagnostic Codes</a></li></ol></li><li class="chapter-item "><a href="ice-breaker/about.html"><strong aria-hidden="true">1.14.</strong> ICE-breaker teams</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ice-breaker/cleanup-crew.html"><strong aria-hidden="true">1.14.1.</strong> &quot;Cleanup Crew&quot; ICE-breakers</a></li><li class="chapter-item "><a href="ice-breaker/llvm.html"><strong aria-hidden="true">1.14.2.</strong> LLVM ICE-breakers</a></li></ol></li><li class="chapter-item "><a href="licenses.html"><strong aria-hidden="true">1.15.</strong> Licenses</a></li></ol></li><li class="chapter-item expanded "><a href="part-2-intro.html"><strong aria-hidden="true">2.</strong> Part 2: 高层编译器架构</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="overview.html"><strong aria-hidden="true">2.1.</strong> Overview of the Compiler</a></li><li class="chapter-item "><a href="compiler-src.html"><strong aria-hidden="true">2.2.</strong> 编译器源码结构</a></li><li class="chapter-item "><a href="query.html"><strong aria-hidden="true">2.3.</strong> 查询：需求驱动的编译</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="queries/query-evaluation-model-in-detail.html"><strong aria-hidden="true">2.3.1.</strong> 查询求值模型的详细介绍</a></li><li class="chapter-item "><a href="queries/incremental-compilation.html"><strong aria-hidden="true">2.3.2.</strong> Incremental compilation</a></li><li class="chapter-item "><a href="queries/incremental-compilation-in-detail.html"><strong aria-hidden="true">2.3.3.</strong> Incremental compilation In Detail</a></li><li class="chapter-item "><a href="incrcomp-debugging.html"><strong aria-hidden="true">2.3.4.</strong> Debugging and Testing</a></li><li class="chapter-item "><a href="queries/profiling.html"><strong aria-hidden="true">2.3.5.</strong> Profiling Queries</a></li><li class="chapter-item "><a href="salsa.html"><strong aria-hidden="true">2.3.6.</strong> Salsa</a></li></ol></li><li class="chapter-item "><a href="memory.html"><strong aria-hidden="true">2.4.</strong> Memory Management in Rustc</a></li></ol></li><li class="chapter-item expanded "><a href="part-3-intro.html"><strong aria-hidden="true">3.</strong> Part 3: 源代码的不同表示</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="rustc-driver.html"><strong aria-hidden="true">3.1.</strong> The Rustc Driver and Interface</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="rustdoc.html"><strong aria-hidden="true">3.1.1.</strong> Rustdoc</a></li><li class="chapter-item "><a href="rustc-driver-interacting-with-the-ast.html"><strong aria-hidden="true">3.1.2.</strong> Ex: Type checking through rustc_interface</a></li></ol></li><li class="chapter-item "><a href="syntax-intro.html"><strong aria-hidden="true">3.2.</strong> 符号与AST</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="the-parser.html"><strong aria-hidden="true">3.2.1.</strong> 词法分析与文法分析</a></li><li class="chapter-item "><a href="test-implementation.html"><strong aria-hidden="true">3.2.2.</strong> #[test] Implementation</a></li><li class="chapter-item "><a href="panic-implementation.html"><strong aria-hidden="true">3.2.3.</strong> Panic Implementation</a></li><li class="chapter-item "><a href="macro-expansion.html"><strong aria-hidden="true">3.2.4.</strong> Macro expansion</a></li><li class="chapter-item "><a href="name-resolution.html"><strong aria-hidden="true">3.2.5.</strong> Name resolution</a></li><li class="chapter-item "><a href="ast-validation.html"><strong aria-hidden="true">3.2.6.</strong> AST Validation</a></li><li class="chapter-item "><a href="feature-gate-ck.html"><strong aria-hidden="true">3.2.7.</strong> Feature Gate Checking</a></li></ol></li><li class="chapter-item "><a href="hir.html"><strong aria-hidden="true">3.3.</strong> HIR （高层IR）</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="lowering.html"><strong aria-hidden="true">3.3.1.</strong> 将AST lower 到 HIR</a></li><li class="chapter-item "><a href="hir-debugging.html"><strong aria-hidden="true">3.3.2.</strong> Debugging</a></li></ol></li><li class="chapter-item "><a href="mir/index.html"><strong aria-hidden="true">3.4.</strong> MIR （中层IR）</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="mir/construction.html"><strong aria-hidden="true">3.4.1.</strong> HAIR 与 MIR 的构造</a></li><li class="chapter-item "><a href="mir/visitor.html"><strong aria-hidden="true">3.4.2.</strong> MIR 访问者与遍历</a></li><li class="chapter-item "><a href="mir/passes.html"><strong aria-hidden="true">3.4.3.</strong> MIR passes: 为一个函数获取MIR</a></li></ol></li><li class="chapter-item "><a href="closure.html"><strong aria-hidden="true">3.5.</strong> Closure expansion</a></li></ol></li><li class="chapter-item expanded "><a href="part-4-intro.html"><strong aria-hidden="true">4.</strong> Part 4: 分析</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ty.html" class="active"><strong aria-hidden="true">4.1.</strong> ty 模块：类型的表示</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="generics.html"><strong aria-hidden="true">4.1.1.</strong> 范型和替换</a></li><li class="chapter-item "><a href="ty-fold.html"><strong aria-hidden="true">4.1.2.</strong> TypeFolder and TypeFoldable</a></li><li class="chapter-item "><a href="generic_arguments.html"><strong aria-hidden="true">4.1.3.</strong> Generic arguments</a></li></ol></li><li class="chapter-item "><a href="type-inference.html"><strong aria-hidden="true">4.2.</strong> Type inference</a></li><li class="chapter-item "><a href="traits/resolution.html"><strong aria-hidden="true">4.3.</strong> Trait solving (old-style)</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="traits/hrtb.html"><strong aria-hidden="true">4.3.1.</strong> Higher-ranked trait bounds</a></li><li class="chapter-item "><a href="traits/caching.html"><strong aria-hidden="true">4.3.2.</strong> Caching subtleties</a></li><li class="chapter-item "><a href="traits/specialization.html"><strong aria-hidden="true">4.3.3.</strong> Specialization</a></li></ol></li><li class="chapter-item "><a href="traits/index.html"><strong aria-hidden="true">4.4.</strong> Trait solving (new-style)</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="traits/lowering-to-logic.html"><strong aria-hidden="true">4.4.1.</strong> Lowering to logic</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="traits/goals-and-clauses.html"><strong aria-hidden="true">4.4.1.1.</strong> Goals and clauses</a></li><li class="chapter-item "><a href="traits/associated-types.html"><strong aria-hidden="true">4.4.1.2.</strong> Equality and associated types</a></li><li class="chapter-item "><a href="traits/implied-bounds.html"><strong aria-hidden="true">4.4.1.3.</strong> Implied bounds</a></li><li class="chapter-item "><a href="traits/regions.html"><strong aria-hidden="true">4.4.1.4.</strong> Region constraints</a></li><li class="chapter-item "><a href="traits/lowering-module.html"><strong aria-hidden="true">4.4.1.5.</strong> The lowering module in rustc</a></li><li class="chapter-item "><a href="traits/lowering-rules.html"><strong aria-hidden="true">4.4.1.6.</strong> Lowering rules</a></li><li class="chapter-item "><a href="traits/wf.html"><strong aria-hidden="true">4.4.1.7.</strong> Well-formedness checking</a></li></ol></li><li class="chapter-item "><a href="traits/canonical-queries.html"><strong aria-hidden="true">4.4.2.</strong> Canonical queries</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="traits/canonicalization.html"><strong aria-hidden="true">4.4.2.1.</strong> Canonicalization</a></li></ol></li><li class="chapter-item "><a href="traits/slg.html"><strong aria-hidden="true">4.4.3.</strong> The SLG solver</a></li><li class="chapter-item "><a href="traits/chalk-overview.html"><strong aria-hidden="true">4.4.4.</strong> An Overview of Chalk</a></li><li class="chapter-item "><a href="traits/bibliography.html"><strong aria-hidden="true">4.4.5.</strong> Bibliography</a></li></ol></li><li class="chapter-item "><a href="type-checking.html"><strong aria-hidden="true">4.5.</strong> Type checking</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="method-lookup.html"><strong aria-hidden="true">4.5.1.</strong> Method Lookup</a></li><li class="chapter-item "><a href="variance.html"><strong aria-hidden="true">4.5.2.</strong> Variance</a></li><li class="chapter-item "><a href="opaque-types-type-alias-impl-trait.html"><strong aria-hidden="true">4.5.3.</strong> Opaque Types</a></li></ol></li><li class="chapter-item "><a href="pat-exhaustive-checking.html"><strong aria-hidden="true">4.6.</strong> Pattern and Exhaustiveness Checking</a></li><li class="chapter-item "><a href="borrow_check.html"><strong aria-hidden="true">4.7.</strong> The borrow checker</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="borrow_check/moves_and_initialization.html"><strong aria-hidden="true">4.7.1.</strong> Tracking moves and initialization</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="borrow_check/moves_and_initialization/move_paths.html"><strong aria-hidden="true">4.7.1.1.</strong> Move paths</a></li></ol></li><li class="chapter-item "><a href="borrow_check/type_check.html"><strong aria-hidden="true">4.7.2.</strong> MIR type checker</a></li><li class="chapter-item "><a href="borrow_check/region_inference.html"><strong aria-hidden="true">4.7.3.</strong> Region inference</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="borrow_check/region_inference/constraint_propagation.html"><strong aria-hidden="true">4.7.3.1.</strong> Constraint propagation</a></li><li class="chapter-item "><a href="borrow_check/region_inference/lifetime_parameters.html"><strong aria-hidden="true">4.7.3.2.</strong> Lifetime parameters</a></li><li class="chapter-item "><a href="borrow_check/region_inference/member_constraints.html"><strong aria-hidden="true">4.7.3.3.</strong> Member constraints</a></li><li class="chapter-item "><a href="borrow_check/region_inference/placeholders_and_universes.html"><strong aria-hidden="true">4.7.3.4.</strong> Placeholders and universes</a></li><li class="chapter-item "><a href="borrow_check/region_inference/closure_constraints.html"><strong aria-hidden="true">4.7.3.5.</strong> Closure constraints</a></li><li class="chapter-item "><a href="borrow_check/region_inference/error_reporting.html"><strong aria-hidden="true">4.7.3.6.</strong> Error reporting</a></li></ol></li><li class="chapter-item "><a href="borrow_check/two_phase_borrows.html"><strong aria-hidden="true">4.7.4.</strong> Two-phase-borrows</a></li></ol></li><li class="chapter-item "><a href="param_env.html"><strong aria-hidden="true">4.8.</strong> Parameter Environments</a></li></ol></li><li class="chapter-item expanded "><a href="part-5-intro.html"><strong aria-hidden="true">5.</strong> Part 5: From MIR to binaries</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="mir/index.html"><strong aria-hidden="true">5.1.</strong> The MIR (Mid-level IR)</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="mir/optimizations.html"><strong aria-hidden="true">5.1.1.</strong> MIR optimizations</a></li><li class="chapter-item "><a href="mir/debugging.html"><strong aria-hidden="true">5.1.2.</strong> Debugging</a></li></ol></li><li class="chapter-item "><a href="const-eval.html"><strong aria-hidden="true">5.2.</strong> Constant evaluation</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="miri.html"><strong aria-hidden="true">5.2.1.</strong> miri const evaluator</a></li></ol></li><li class="chapter-item "><a href="backend/monomorph.html"><strong aria-hidden="true">5.3.</strong> Monomorphization</a></li><li class="chapter-item "><a href="backend/lowering-mir.html"><strong aria-hidden="true">5.4.</strong> Lowering MIR</a></li><li class="chapter-item "><a href="backend/codegen.html"><strong aria-hidden="true">5.5.</strong> Code Generation</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="backend/updating-llvm.html"><strong aria-hidden="true">5.5.1.</strong> Updating LLVM</a></li><li class="chapter-item "><a href="backend/debugging.html"><strong aria-hidden="true">5.5.2.</strong> Debugging LLVM</a></li><li class="chapter-item "><a href="backend/backend-agnostic.html"><strong aria-hidden="true">5.5.3.</strong> Backend Agnostic Codegen</a></li><li class="chapter-item "><a href="codegen/implicit-caller-location.html"><strong aria-hidden="true">5.5.4.</strong> Implicit Caller Location</a></li></ol></li><li class="chapter-item "><a href="profile-guided-optimization.html"><strong aria-hidden="true">5.6.</strong> Profile-guided Optimization</a></li><li class="chapter-item "><a href="sanitizers.html"><strong aria-hidden="true">5.7.</strong> Sanitizers Support</a></li><li class="chapter-item "><a href="debugging-support-in-rustc.html"><strong aria-hidden="true">5.8.</strong> Debugging Support in Rust Compiler</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="appendix/background.html">Appendix A: Background material</a></li><li class="chapter-item expanded affix "><a href="appendix/glossary.html">Appendix B: Glossary</a></li><li class="chapter-item expanded affix "><a href="appendix/code-index.html">Appendix C: Code Index</a></li><li class="chapter-item expanded affix "><a href="appendix/compiler-lecture.html">Appendix D: Compiler Lecture Series</a></li><li class="chapter-item expanded affix "><a href="appendix/bibliography.html">Appendix E: Bibliography</a></li><li class="chapter-item expanded affix "><a href="appendix/humorust.html">Appendix Z: HumorRust</a></li><li class="spacer"></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Guide to Rustc Development</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/longfangsong/rustc-dev-guide-cn" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#ty-模块类型的表示" id="ty-模块类型的表示"><code>ty</code> 模块：类型的表示</a></h1>
<p><code>ty</code>模块定义了Rust编译器如何在内部表示类型。 它还定义了<em>类型上下文</em>（<code>tcx</code>或<code>TyCtxt</code>），这是编译器中的中央数据结构。</p>
<h2><a class="header" href="#tyty" id="tyty"><code>ty::Ty</code></a></h2>
<p>当我们谈论rustc如何表示类型时，我们通常指的是称为<code>Ty</code>的类型。 编译器中有很多<code>Ty</code>的模块和类型（<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/index.html">Ty 文档</a>）。</p>
<p>我们指的<code>Ty</code>是<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/type.Ty.html"><code>rustc::ty:: Ty</code></a>（而不是<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir/struct.Ty.html"><code>rustc_hir::Ty</code></a>）。它们之间的区别很重要，因此我们将在讨论<code>ty::Ty</code>之前先进行讨论。</p>
<h2><a class="header" href="#rustc_hirty-vs-tyty" id="rustc_hirty-vs-tyty"><code>rustc_hir::Ty</code> vs <code>ty::Ty</code></a></h2>
<p>rustc中的HIR可以看作是高级中间表示。
它或多或少是一种AST（请参阅<a href="hir.html">本章</a>），因为它代表用户编写的语法，并且是在语法分析和一些<em>desugaring</em>之后获得的。
它具有类型的表示形式，但实际上它反映了用户编写的内容，即他们为表示该类型而编写的内容。</p>
<p>相反，<code>ty::Ty</code>表示类型的语义，即用户编写内容的<em>含义</em>。
例如，<code>rustc_hir::Ty</code>会记录用户在程序中使用了两次<code>u32</code>这个名字，但是<code>ty::Ty</code>会记录两种用法都指向同一类型。</p>
<p><strong>例如： <code>fn foo(x: u32) → u32 { }</code></strong> 在这个函数中，我们看到<code>u32</code>出现了两次。
我们知道这是同一类型，即该函数接受一个参数并返回相同类型的参数，但是从HIR的角度来看，将存在两个不同的类型实例，因为它们分别在程序中的两个不同位置出现。
也就是说，它们有两个不同的<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/struct.Span.html"><code>Span</code></a>（位置）。</p>
<p><strong>例如： <code>fn foo(x: &amp;u32) -&gt; &amp;u32)</code></strong> 另外，HIR可能遗漏了信息。
<code>&amp;u32</code>类型是不完整的，因为在完整的Rust类型中实际上这里应该存在一个生命周期，但是我们不需要编写这些生命周期。
还有一些省略规则可以插入信息。
结果可能看起来像<code>fn foo&lt;'a&gt;(x: &amp;'a u32) -&gt; &amp;'a u32)</code>.</p>
<p>在HIR级别上，这些内容并未阐明。
但是，在<code>ty::Ty</code>级别，添加了这些详细信息。
此外，对于给定类型，我们将只有一个<code>ty::Ty</code>，例如<code>u32</code>，并且该<code>ty::Ty</code>用于整个程序中的所有u32，而不是只在特定场景中使用，这与 <code>rustc_hir::Ty</code>不同。</p>
<p>这里有一个总结：</p>
<table><thead><tr><th><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir/struct.Ty.html"><code>rustc_hir::Ty</code></a></th><th><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/type.Ty.html"><code>ty::Ty</code></a></th></tr></thead><tbody>
<tr><td>描述类型的<em>语法</em>：用户写的内容（去除了一些语法糖）。</td><td>描述一种类型的“语义”：用户写的内容的含义。</td></tr>
<tr><td>每个<code>rustc_hir::Ty</code>都有自己的span，对应于程序中的适当位置。</td><td>与用户程序中的单个位置不对应。</td></tr>
<tr><td><code>rustc_hir::Ty</code>具有泛型和生命周期； 但是，其中一些生命周期是特殊标记，例如<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir/enum.LifetimeName.html#variant.Implicit"><code>LifetimeName::Implicit</code></a>。</td><td><code>ty::Ty</code>具有完整的类型，包括泛型和生命周期，即使用户忽略了它们</td></tr>
<tr><td><code>fn foo(x: u32) → u32 { }</code> —— 两个<code>rustc_hir::Ty</code>代表了<code>u32</code>的两次不同的使用。 每个都有自己的<code>Span</code>等。——<code>rustc_hir::Ty</code>不能告诉我们两者是同一类型</td><td>整个程序中所有<code>u32</code>是同一个<code>ty::Ty</code>。——<code>ty::Ty</code>告诉我们，<code>u32</code>的两次使用表示相同的类型。</td></tr>
<tr><td><code>fn foo(x: &amp;u32) -&gt; &amp;u32)</code> —— 仍然有两个<code>rustc_hir::Ty</code>。 —— 在<code>rustc_hir::Ty</code>中这两个引用的生命期使用特殊标记<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir/enum.LifetimeName.html#variant.Implicit">`LifetimeName::Implicit</a>表示。</td><td><code>fn foo(x: &amp;u32) -&gt; &amp;u32)</code> —— 单个<code>ty::Ty</code>。—— <code>ty::Ty</code>具有隐藏的生命周期参数</td></tr>
</tbody></table>
<p><strong>次序</strong>  HIR是直接从AST构建的，因此会在生成任何<code>ty::Ty</code>之前发生。
构建HIR之后，将完成一些基本的类型推断和类型检查。
在类型推断过程中，我们找出所有事物的<code>ty::Ty</code>是什么，并且还要检查某事物的类型是否不明确。
然后，<code>ty::Ty</code>将用于类型检查，来确保所有内容都具有预期的类型。
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_typeck/astconv/index.html"><code>astconv</code>模块</a>是负责将<code>rustc_hir::Ty</code>转换为<code>ty::Ty</code>的代码所在的位置。 
这发生在类型检查阶段，但也发生在编译器的其他部分，例如“该函数需要什么样的参数类型”之类的问题。</p>
<p><strong>语义如何驱动两个<code>Ty</code>实例</strong> 您可以将HIR视为对类型信息假设最少的视角。
我们假设两件事是截然不同的，直到证明它们是同一件事为止。
换句话说，我们对它们的了解较少，因此我们应该对它们的假设较少。</p>
<p>从文法上讲,第N行第20列的<code>&quot;u32&quot;</code>和第N行第35列的<code>&quot;u32&quot;</code>是两个字符串。我们尚不知道它们是否相同。 因此，在HIR中，我们将它们视为不同的。
后来，我们确定它们在语义上是相同的类型，这就是我们使用<code>ty::Ty</code>的地方。</p>
<p>考虑另一个例子： <code>fn foo&lt;T&gt;(x: T) -&gt; u32</code> 假设有人调用了 <code>foo::&lt;u32&gt;(0)</code>。</p>
<p>这意味着<code>T</code>和<code>u32</code>（在本次调用中）实际上是相同的类型，因此最终我们最终将得到相同的<code>ty::Ty</code>，但是我们有截然不同的<code>rustc_hir::Ty</code>。</p>
<p>（不过，这有点过于简化了，因为在类型检查过程中，我们将对函数范型检查，并且仍然具有不同于<code>u32</code>的<code>T</code>。
之后，在进行代码生成时，我们将始终处理每个函数的“单态化&quot;（完全替换的）版本，因此我们将知道<code>T</code>代表什么（特别是它是<code>u32</code>）。</p>
<p>这里还有一个例子：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>mod a {
    type X = u32;
    pub fn foo(x: X) -&gt; i32 { 22 }
}
mod b {
    type X = i32;
    pub fn foo(x: X) -&gt; i32 { x }
}
<span class="boring">}
</span></code></pre></pre>
<p>显然，这里的<code>X</code>类型将根据上下文而变化。 如果查看<code>rustc_hir::Ty</code>，您会发现<code>X</code>在两种情况下都是别名（尽管它将通过名称解析映射到不同的别名）。
但是，如果您查看<code>ty::Ty</code>中的函数签名，它将是 <code>fn(u32) -&gt; u32</code>或<code>fn(i32) -&gt; i32</code>（类型别名已完全展开）。</p>
<h2><a class="header" href="#tyty-的实现" id="tyty-的实现"><code>ty::Ty</code> 的实现</a></h2>
<p><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/type.Ty.html"><code>rustc::ty::Ty</code></a>实际上是<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TyS.html"><code>&amp;TyS</code></a>的类型别名（稍后会详细介绍）。
<code>TyS</code>（Type Structure）是主要功能所在的位置。
您通常可以忽略<code>TyS</code>结构；您基本上永远不会显式访问它。我们总是使用<code>Ty</code>别名通过引用传递它。
唯一的例外是在类型上定义固有方法。
特别地，<code>TyS</code>具有类型为<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/enum.TyKind.html"><code>TyKind</code></a>的<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TyS.html#structfield.kind"><code>kind</code></a>字段，其表示关键类型信息。
<code>TyKind</code>是一个很大的枚举，代表了不同类型的类型（例如原生类型，引用，抽象数据类型，泛型，生命周期等）。
<code>TyS</code>还有另外2个字段：<code>flags</code>和<code>outer_exclusive_binder</code>。
它们是提高效率的便捷工具，可以汇总有关我们可能想知道的类型的信息，但本文并不多涉及这部分内容。
最后，<code>ty::TyS</code>是<a href="./memory.html">interned</a>的，以便使<code>ty::TyS</code>可以是类似于指针的瘦类型。这使我们能够进行低成本的相等比较，以及其他的interning的好处。</p>
<h2><a class="header" href="#分配和使用类型" id="分配和使用类型">分配和使用类型</a></h2>
<p>要分配新类型，可以使用在<code>tcx</code>上定义的各种<code>mk_</code>方法。 它们的名称主要对应于各种类型。 例如：</p>
<pre><code class="language-rust ignore">let array_ty = tcx.mk_array(elem_ty, len * 2);
</code></pre>
<p>这些方法都返回<code>Ty&lt;'tcx&gt;</code> —— 注意，返回的生命周期是该<code>tcx</code>可以访问的生命周期。 类型总是被规范化和interned（因此我们永远不会两次分配完全相同的类型）。</p>
<blockquote>
<p>注意 由于类型是interned的，因此可以使用<code>==</code>高效地比较它们是否相等 —— 但是，除非您碰巧正在散列并寻找重复项，否则您应该不会希望这么做。 
这是因为在Rust中通常有多种方法来表示同一类型，特别是一旦涉及到类型推断。
如果要测试类型相等性，则可能需要开始研究类型推倒的代码才能正确完成。</p>
</blockquote>
<p>您还可以通过访问<code>tcx.types.bool</code>，<code>tcx.types.char</code>等来在<code>tcx</code>中找到各种常见类型（有关更多信息，请参见 <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/context/struct.CommonTypes.html"><code>CommonTypes</code></a>。）。</p>
<h2><a class="header" href="#tytykind-的变体" id="tytykind-的变体"><code>ty::TyKind</code> 的变体</a></h2>
<p>注意：<code>TyKind</code> <strong>并非</strong> <em>Kind</em>的函数式编程概念。</p>
<p>每当在编译器中使用<code>Ty</code>时，通常会在类型上进行匹配：</p>
<pre><code class="language-rust ignore">fn foo(x: Ty&lt;'tcx&gt;) {
  match x.kind {
    ...
  }
}
</code></pre>
<p><code>kind</code>字段的类型为<code>TyKind&lt;'tcx&gt;</code>，它是一个枚举，用于定义编译器中所有不同种类的类型。</p>
<blockquote>
<p>N.B. 在类型推断过程中检查类型的<code>kind</code>字段可能会很冒险，因为可能会有推断变量和其他要考虑的因素，或者有时类型未知，并且稍后将变得已知。</p>
</blockquote>
<p>相关类型的很多，我们会及时介绍（例如，区域/生命周期，“替代”等）。</p>
<p><code>TyKind</code>枚举上有很多变体，您可以通过查看rustdocs来看到。 这是一个样本：</p>
<p><a href=""><strong>代数数据类型（ADT）</strong></a> <a href="https://en.wikipedia.org/wiki/Algebraic_data_type"><em>代数数据类型</em></a>是<code>struct</code>，<code>enum</code>或<code>union</code>。 
实际上，<code>struct</code>，<code>enum</code>和<code>union</code>是用相同的方式实现的：它们都是<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/enum.TyKind.html#variant.Adt"><code>ty::TyKind::Adt</code></a>类型。
这基本上是用户定义的类型。稍后我们将详细讨论。</p>
<p><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/enum.TyKind.html#variant.Foreign"><strong>Foreign</strong></a> 对应 <code>extern type T</code>.</p>
<p><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/enum.TyKind.html#variant.Str"><strong>Str</strong></a> 是str类型。当用户编写<code>&amp;str</code>时，<code>Str</code>是我们表示该类型的<code>str</code>部分的方式。</p>
<p><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/enum.TyKind.html#variant.Slice"><strong>Slice</strong></a> 对应 <code>[T]</code>.</p>
<p><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/enum.TyKind.html#variant.Array"><strong>Array</strong></a> 对应 <code>[T; n]</code>.</p>
<p><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/enum.TyKind.html#variant.RawPtr"><strong>RawPtr</strong></a> 对应 <code>*mut T</code> 或者 <code>*const T</code></p>
<p><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/enum.TyKind.html#variant.Ref"><strong>Ref</strong></a> <code>Ref</code>代表安全的引用，<code>&amp;'a mut T</code>或<code>&amp;'a T</code>。
<code>Ref</code>具有一些相关类型，例如，<code>Ty&lt;tcx&gt;</code>是引用所引用的类型，<code>Region&lt;tcx&gt;</code>是引用的生命周期或区域，<code>Mutability</code>则是引用的可变性。 </p>
<p><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/enum.TyKind.html#variant.Param"><strong>Param</strong></a> 代表类型参数，如<code>Vec&lt;T&gt;</code>中的<code>T</code>。</p>
<p><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/enum.TyKind.html#variant.Error"><strong>Error</strong></a> 在某处表示类型错误，以便我们可以打印出更好的诊断信息。 我们将在后面讨论它。</p>
<p><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/enum.TyKind.html#variants"><strong>以及更多</strong>...</a></p>
<h2><a class="header" href="#import-约定" id="import-约定">Import 约定</a></h2>
<p>尽管没有硬性规定，但是<code>ty</code>模块的用法通常如下：</p>
<pre><code class="language-rust ignore">use ty::{self, Ty, TyCtxt};
</code></pre>
<p>由于<code>Ty</code>和<code>TyCtxt</code>类型使用得非常普遍，因此可以直接导入。
其他类型通常使用显式的<code>ty::</code>前缀来引用（例如<code>ty::TraitRef&lt;'tcx&gt;</code>）。
但是某些模块选择显式导入更大或更小的名称集。</p>
<h2><a class="header" href="#adt的表示" id="adt的表示">ADT的表示</a></h2>
<p>让我们考虑像<code>MyStruct&lt;u32&gt;</code>这样的类型的例子，其中MyStruct的定义如下：</p>
<pre><code class="language-rust ignore">struct MyStruct&lt;T&gt; { x: u32, y: T }
</code></pre>
<p>类型<code>MyStruct&lt;u32&gt;</code>将是<code>TyKind::Adt</code>的实例：</p>
<pre><code class="language-rust ignore">Adt(&amp;'tcx AdtDef, SubstsRef&lt;'tcx&gt;)
//  ------------  ---------------
//  (1)            (2)
//
// (1) 表示 `MyStruct` 部分
// (2) 表示 `&lt;u32&gt;`, 或者 &quot;substitutions&quot; / 范型参数
</code></pre>
<p>有两个部分：</p>
<ul>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.AdtDef.html"><code>AdtDef</code></a>引用struct/enum/union，但没有类型参数的值。
在我们的示例中，这是MyStruct部分，<em>没有</em>参数u32。
<ul>
<li>请注意，在HIR中，结构体，枚举和union的表示方式是不同的，但是在<code>ty::Ty</code>中，它们均使用<code>TyKind::Adt</code>表示。</li>
</ul>
</li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/subst/type.SubstsRef.html"><code>SubstsRef</code></a>是要替换的范型参数值的内部列表。
在我们的<code>MyStruct&lt;u32&gt;</code>的示例中，我们会得到一个类似<code>[u32]</code>的列表。
稍后，我们将进一步探讨泛型和替换。</li>
</ul>
<p><strong><code>AdtDef</code> 和 <code>DefId</code></strong></p>
<p>对于源代码中定义的每种类型，都有一个唯一的<code>DefId</code>（请参阅<a href="hir.html#identifiers-in-the-hir">本章</a>）。
这包括ADT和泛型。 在上面给出的<code>MyStruct&lt;T&gt;</code>定义中，有两个<code>DefId</code>：一个用于<code>MyStruct</code>，一个用于<code>T</code>。
注意，上面的代码不会为<code>u32</code>生成新的<code>DefId</code>，因为该代码并不定义<code>u32</code>（而仅是引用它）。</p>
<p><code>AdtDef</code>或多或少是<code>DefId</code>的包装，其中包含许多有用的辅助方法。
<code>AdtDef</code>和<code>DefId</code>之间本质上是一对一的关系。
您可以通过<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TyCtxt.html#method.adt_def"><code>tcx.adt_def(def_id)</code>查询</a><code>DefId</code>对应的<code>AdtDef</code>。 所有<code>AdtDef</code>都被缓存了（您可以看到其上的<code>'tcx</code>生命周期）。</p>
<h2><a class="header" href="#类型错误" id="类型错误">类型错误</a></h2>
<p>用户制造了类型错误时会生成<code>TyKind::Error</code>。
我们的想法是，我们将传播这种类型并抑制由于该类型而引起的其他错误，以免级联的编译器错误消息使用户不知所措。</p>
<p><code>TyKind::Error</code>的使用有一个<strong>重要的原则</strong>。
除非您知道已经向用户报告了错误，否则您<strong>绝不要</strong>返回“错误类型”。
通常是因为（a）您刚刚在此报告了该错误，或者（b）您正在传播现有的Error类型（在这种情况下，应该在生成该错误类型时报告该错误）。</p>
<p>此原则非常重要，因为<code>Error</code>类型的全部目的就是抑制其他错误——即，我们不报告它们。
如果我们在不向用户实际制造了错误的情况下生成<code>Error</code>类型，则这可能导致以后的错误被抑制，并且编译可能会无意中成功！</p>
<p>有时还有第三种情况。
您认为已报告了一个错误，但是您认为该错误将在编译的更早阶段而不是现在得到报告。
在这种情况下，您可以调用<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_session/struct.Session.html#method.delay_span_bug"><code>delay_span_bug</code></a>，这表示编译应该会产生错误——如果编译意外地成功了，则将触发编译器错误报告。</p>
<h2><a class="header" href="#问题为什么在adtdef内部做替换" id="问题为什么在adtdef内部做替换">问题：为什么在<code>AdtDef</code>“内部”做替换？</a></h2>
<p>回想一下，我们用<code>(AdtDef，substs)</code>表示一个范型结构体。 那么，为什么要使用这种麻烦的模式？</p>
<p>我们可以选择表示这种类型的另一种方法是始终创建一个新的，完全不同的<code>AdtDef</code>形式，其中所有类型都已被替换。
这样做好像比较方便。 但是，<code>(AdtDef，substs)</code>方案对此有一些优势。</p>
<p>首先，<code>(AdtDef，substs)</code>方案可以提高效率：</p>
<pre><code class="language-rust ignore">struct MyStruct&lt;T&gt; {
  ... 100s of fields ...
}

// Want to do: MyStruct&lt;A&gt; ==&gt; MyStruct&lt;B&gt;
</code></pre>
<p>在像这样的示例中，只需将对<code>A</code>的一个引用替换为<code>B</code>，就可以低成本地地将<code>MyStruct&lt;A&gt;</code>替换为<code>MyStruct&lt;B&gt;</code>（依此类推）。 
但是，如果我们替换所有字段，则可能需要多做很多工作，我们可能必须遍历<code>AdtDef</code>中的所有字段并更新所有类型。</p>
<p>更深入一点来说，Rust中的结构体是<a href="https://en.wikipedia.org/wiki/Nominal_type_system"><em>nominal</em> 类型</a>——这意味着它们是由其名称定义的（然后它们的内容将从该名称的定义中进行索引，而不是携带在类型本身“内”）。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="part-4-intro.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="generics.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="part-4-intro.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="generics.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
